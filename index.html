<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Portfolio Grid</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  </head>

  <div class="center-toggle">
    <label class="switch">
      <input type="checkbox" id="bubbleToggle" />
      <span class="slider"></span>
    </label>
  </div>

  <body>
    <main class="main">
      <div class="grid" id="projectGrid">
        <a class="project" data-tags="" href="project0001.html">
          <img src="projects/0001/image1.jpg" alt="0001" class="project-img" />
          <span class="project-label">0001</span>
        </a>

        <a class="project" data-tags="" href="project0002.html">
          <img src="projects/0002/image1.jpg" alt="0002" class="project-img" />
          <span class="project-label">0002</span>
        </a>

        <a class="project" data-tags="" href="project0003.html">
          <img src="projects/0003/image1.jpg" alt="0003" class="project-img" />
          <span class="project-label">0003</span>
        </a>
      </div>
    </main>

    <canvas id="bubbleCanvas"></canvas>

    <script>
      const grid = document.getElementById("projectGrid");
      const projects = Array.from(document.querySelectorAll(".project"));
      const toggle = document.getElementById("bubbleToggle");

      // Store original positions for reset
      let originalRects = [];
      let engine,
        render,
        runner,
        bodies = [],
        mouseConstraint;

      function storeOriginalPositions() {
        originalRects = projects.map((el) => el.getBoundingClientRect());
      }

      function startBubblePhysics() {
        // Hide grid layout (optional: set grid to position: relative)
        grid.style.position = "relative";

        // Get grid position relative to viewport
        const gridRect = grid.getBoundingClientRect();

        // Create Matter.js engine and world
        engine = Matter.Engine.create();
        render = Matter.Render.create({
          element: grid,
          engine: engine,
          options: {
            width: grid.offsetWidth,
            height: grid.offsetHeight,
            wireframes: false,
            background: "transparent",
          },
        });

        // Create boundaries (walls)
        const wallThickness = 50;
        const walls = [
          Matter.Bodies.rectangle(
            grid.offsetWidth / 2,
            -wallThickness / 2,
            grid.offsetWidth,
            wallThickness,
            { isStatic: true }
          ),
          Matter.Bodies.rectangle(
            grid.offsetWidth / 2,
            grid.offsetHeight + wallThickness / 2,
            grid.offsetWidth,
            wallThickness,
            { isStatic: true }
          ),
          Matter.Bodies.rectangle(
            -wallThickness / 2,
            grid.offsetHeight / 2,
            wallThickness,
            grid.offsetHeight,
            { isStatic: true }
          ),
          Matter.Bodies.rectangle(
            grid.offsetWidth + wallThickness / 2,
            grid.offsetHeight / 2,
            wallThickness,
            grid.offsetHeight,
            { isStatic: true }
          ),
        ];
        Matter.World.add(engine.world, walls);

        // Create bubbles for each project
        bodies = projects.map((el, i) => {
          el.style.position = "absolute";
          el.style.transition = "none";
          el.style.zIndex = 10;

          // Place in original grid position
          const rect = el.getBoundingClientRect();
          const x = rect.left - gridRect.left + rect.width / 2;
          const y = rect.top - gridRect.top + rect.height / 2;
          const r = rect.width / 2;

          // Place element at (x, y)
          el.style.left = x - r + "px";
          el.style.top = y - r + "px";

          // Create physics body
          const body = Matter.Bodies.circle(x, y, r, {
            restitution: 0.8,
            friction: 0.01,
            frictionAir: 0.01,
          });
          body.el = el;
          Matter.World.add(engine.world, body);
          return body;
        });

        // Mouse/touch drag
        mouseConstraint = Matter.MouseConstraint.create(engine, {
          element: grid,
          constraint: { stiffness: 0.2, render: { visible: false } },
        });
        Matter.World.add(engine.world, mouseConstraint);

        // Sync DOM elements with physics bodies
        Matter.Events.on(engine, "afterUpdate", () => {
          bodies.forEach((body) => {
            const r = body.circleRadius;
            body.el.style.left = body.position.x - r + "px";
            body.el.style.top = body.position.y - r + "px";
          });
        });

        // Device orientation / mouse movement for gravity
        window.addEventListener("deviceorientation", handleOrientation);
        window.addEventListener("mousemove", handleMouseMove);

        // Start engine and render
        Matter.Render.run(render);
        runner = Matter.Runner.create();
        Matter.Runner.run(runner, engine);

        // "Explode": apply random outward force
        setTimeout(() => {
          bodies.forEach((body) => {
            const angle = Math.random() * 2 * Math.PI;
            const force = 0.08 + Math.random() * 0.07;
            Matter.Body.applyForce(body, body.position, {
              x: Math.cos(angle) * force,
              y: Math.sin(angle) * force,
            });
          });
        }, 100);

        // Hide grid's CSS layout (optional)
        grid.classList.add("bubble-mode");
      }

      function stopBubblePhysics() {
        // Remove event listeners
        window.removeEventListener("deviceorientation", handleOrientation);
        window.removeEventListener("mousemove", handleMouseMove);

        // Stop Matter.js
        Matter.Render.stop(render);
        Matter.Runner.stop(runner);
        render.canvas.remove();
        engine.events = {};

        // Animate bubbles back to grid positions
        projects.forEach((el, i) => {
          el.style.transition = "all 1s cubic-bezier(0.4,2,0.6,1)";
          const rect = originalRects[i];
          const gridRect = grid.getBoundingClientRect();
          const x = rect.left - gridRect.left;
          const y = rect.top - gridRect.top;
          el.style.left = x + "px";
          el.style.top = y + "px";
        });

        // After animation, reset styles and grid layout
        setTimeout(() => {
          projects.forEach((el) => {
            el.style.position = "";
            el.style.left = "";
            el.style.top = "";
            el.style.transition = "";
            el.style.zIndex = "";
          });
          grid.classList.remove("bubble-mode");
        }, 1000);
      }

      function handleOrientation(event) {
        if (!engine) return;
        // gamma: left/right, beta: up/down
        engine.world.gravity.x = event.gamma / 45;
        engine.world.gravity.y = event.beta / 45;
      }

      function handleMouseMove(event) {
        if (!engine) return;
        // Map mouse X/Y to gravity
        const x = (event.clientX / window.innerWidth - 0.5) * 2;
        const y = (event.clientY / window.innerHeight - 0.5) * 2;
        engine.world.gravity.x = x;
        engine.world.gravity.y = y;
      }

      // Store original positions on load and on resize
      window.addEventListener("DOMContentLoaded", storeOriginalPositions);
      window.addEventListener("resize", storeOriginalPositions);

      toggle.addEventListener("change", function () {
        if (toggle.checked) {
          storeOriginalPositions();
          startBubblePhysics();
        } else {
          stopBubblePhysics();
        }
      });
    </script>
  </body>

  <canvas id="bubbleCanvas"></canvas>
</html>
